"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const SchemasDecorators_1 = __importDefault(require("../decorators/SchemasDecorators"));
const DBTypes_1 = require("../enums/DBTypes");
const TypeNotSuportedException_1 = __importDefault(require("../exceptions/TypeNotSuportedException"));
class Type {
    static GetProperties(cTor) {
        let empty = Reflect.construct(cTor, []);
        return Object.keys(empty);
    }
    static GetDesingType(cTor, propertyName) {
        return Reflect.getMetadata("design:type", cTor.prototype, propertyName);
    }
    static GetDesingTimeTypeName(cTor, propertyName) {
        let type = SchemasDecorators_1.default.GetDataTypeAttribute(cTor, propertyName);
        if (type == undefined)
            type = Reflect.getMetadata("design:type", cTor.prototype, propertyName);
        if (typeof type === "function")
            type = type.name;
        return type === null || type === void 0 ? void 0 : type.toString();
    }
    static AsArray(type) {
        if (type == "serial")
            return DBTypes_1.DBTypes.INTEGERARRAY;
        if (type.endsWith("[]"))
            return type;
        else
            return `${type}[]`;
    }
    static InjectMetadata(object, metadata) {
        let meta = Type.ExtractMetadata(object);
        meta = meta.filter(s => s.Field != metadata.Field);
        meta.push(metadata);
        Reflect.set(object, '_orm_metadata_', meta);
    }
    static ExtractMetadata(object) {
        var _a;
        return (_a = Reflect.get(object, '_orm_metadata_')) !== null && _a !== void 0 ? _a : [];
    }
    static DeleteMetadata(object) {
        if (Reflect.has(object, "_orm_metadata_")) {
            delete object._orm_metadata_;
        }
    }
    static GetTableName(cTor) {
        var _a;
        return (_a = SchemasDecorators_1.default.GetTableAttribute(cTor)) !== null && _a !== void 0 ? _a : cTor.name;
    }
    static GetColumnName(cTor, key) {
        return SchemasDecorators_1.default.GetColumnAttribute(cTor, key);
    }
    static HasValue(obj) {
        if (typeof obj == "string") {
            return obj.length > 0;
        }
        if (typeof obj == "number") {
            return obj > 0;
        }
        if (typeof obj == "object") {
            return obj != undefined;
        }
        return false;
    }
    static GetColumnNameAndType(cTor) {
        let keys = Type.GetProperties(cTor).filter(s => SchemasDecorators_1.default.GetColumnAttribute(cTor, s) != undefined);
        let values = [];
        for (let key of keys) {
            let meta = Type.GetColumnName(cTor, key);
            let type = Type.GetDesingTimeTypeName(cTor, key);
            let relation = SchemasDecorators_1.default.GetRelationAttribute(cTor, key);
            if (!type && relation)
                type = relation.TypeBuilder().name;
            if (meta != undefined && type) {
                values.push({
                    Field: key.toString(),
                    Column: meta,
                    Type: type
                });
            }
        }
        return values;
    }
    static IsArray(dbType) {
        switch (dbType.toLowerCase()) {
            case DBTypes_1.DBTypes.INTEGERARRAY: return true;
            case DBTypes_1.DBTypes.TEXTARRAY: return true;
            case DBTypes_1.DBTypes.BOOLEANARRAY: return true;
            case DBTypes_1.DBTypes.DATEARRAY: return true;
            case DBTypes_1.DBTypes.DATETIMEARRAY: return true;
            case DBTypes_1.DBTypes.LONGARRAY: return true;
            case DBTypes_1.DBTypes.DOUBLEARRAY: return true;
        }
        return false;
    }
    static ExtractElementType(dbType) {
        return dbType.toLowerCase().toString().replace('[]', '');
    }
    static IsDate(dbType) {
        switch (dbType.toLowerCase()) {
            case DBTypes_1.DBTypes.DATE: return true;
            case DBTypes_1.DBTypes.DATETIME: return true;
        }
        return false;
    }
    static IsNumber(dbType) {
        switch (dbType.toLowerCase()) {
            case DBTypes_1.DBTypes.LONG: return true;
            case DBTypes_1.DBTypes.SERIAL: return true;
            case DBTypes_1.DBTypes.INTEGER: return true;
            case DBTypes_1.DBTypes.DOUBLE: return true;
        }
        return false;
    }
    static IsText(dbType) {
        switch (dbType.toLowerCase()) {
            case DBTypes_1.DBTypes.TEXT: return true;
        }
        return false;
    }
    /**
     *
     * @method
     * @param {string} type the type from desing type to be converted to a DBTypes enum
     * @returns the DBTypes correspondent
     */
    static CastType(type) {
        for (let k in DBTypes_1.DBTypes) {
            if (DBTypes_1.DBTypes[k] == type.toLowerCase().trim())
                return DBTypes_1.DBTypes[k];
        }
        switch (type.toLowerCase()) {
            case "number": return DBTypes_1.DBTypes.DOUBLE;
            case "string": return DBTypes_1.DBTypes.TEXT;
            case "object": return DBTypes_1.DBTypes.CLASS;
            default: throw new TypeNotSuportedException_1.default(`The type ${type} is not suported or is not mapped in this instance of PGContext`);
        }
    }
}
exports.default = Type;
//# sourceMappingURL=Type.js.map