"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const myorm_core_1 = require("myorm_core");
const Type_1 = __importDefault(require("../core/design/Type"));
const DBTypes_1 = require("../core/enums/DBTypes");
const SchemasDecorators_1 = __importDefault(require("../core/decorators/SchemasDecorators"));
const NotImplementedException_1 = __importDefault(require("../core/exceptions/NotImplementedException"));
const TypeNotSuportedException_1 = __importDefault(require("../core/exceptions/TypeNotSuportedException"));
const InvalidOperationException_1 = __importDefault(require("../core/exceptions/InvalidOperationException"));
const RelationType_1 = require("../core/enums/RelationType");
const ConstraintFailException_1 = __importDefault(require("../core/exceptions/ConstraintFailException"));
const PGFluentField_1 = __importDefault(require("./PGFluentField"));
const PGSetHelper_1 = __importDefault(require("./PGSetHelper"));
class PGDBSet extends myorm_core_1.AbstractSet {
    constructor(cTor, context) {
        super();
        this._statements = [];
        this._ordering = [];
        this._includes = [];
        this._type = cTor;
        this._table = Type_1.default.GetTableName(cTor);
        this._maps = Type_1.default.GetColumnNameAndType(cTor);
        this._manager = context["_manager"];
        this._context = context;
        this._set = new PGSetValue();
    }
    AddObjectAndRelationsAsync(obj, relations) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.AddObjectAsync(obj, false, relations);
        });
    }
    AddAsync(obj) {
        return this.AddObjectAsync(obj);
    }
    AddObjectAsync(obj, cascade = true, relations = [], visiteds = []) {
        return this.CreatePromisse(() => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            visiteds = visiteds !== null && visiteds !== void 0 ? visiteds : [];
            if (!obj)
                throw new InvalidOperationException_1.default(`Cannot insert a null reference object of ${this._type.name}`);
            if (!this.IsCorrectType(obj))
                throw new InvalidOperationException_1.default(`The object passed as argument is not a ${this._type.name} instance`);
            let sql = `insert into "${this._table}"(`;
            let values = `values (`;
            let returnKey = '';
            let key;
            let subTypes = [];
            for (let map of this._maps) {
                if (SchemasDecorators_1.default.IsPrimaryKey(this._type, map.Field)) {
                    returnKey = `returning ${map.Column}`;
                    key =
                        {
                            Column: map.Column,
                            Property: map.Field
                        };
                    continue;
                }
                let currPropValue = Reflect.get(obj, map.Field);
                if (currPropValue == undefined || currPropValue == null) {
                    sql += `"${map.Column}",`;
                    values += `null,`;
                    continue;
                }
                let relation = SchemasDecorators_1.default.GetRelationAttribute(this._type, map.Field);
                let designType = Type_1.default.GetDesingType(this._type, map.Field);
                if ((designType && this._context.IsMapped(designType)) || (relation && this._context.IsMapped(relation.TypeBuilder()))) {
                    subTypes.push({
                        Column: map.Column,
                        Field: map.Field,
                        Type: map.Type
                    });
                    continue;
                }
                let colType = Type_1.default.CastType(map.Type);
                sql += `"${map.Column}",`;
                values += `${this.CreateValueStatement(colType, Reflect.get(obj, map.Field))},`;
            }
            if (key == undefined)
                throw new InvalidOperationException_1.default(`The type ${this._type.name} must have a primary key field`);
            if (visiteds.filter(s => s && s.constructor == obj.constructor && Reflect.get(s, key.Property) == Reflect.get(obj, key.Property)).length > 0)
                return obj;
            visiteds.push(obj);
            if (Type_1.default.HasValue(Reflect.get(obj, key.Property)))
                throw new InvalidOperationException_1.default(`Can not add a ${this._type.name} with ${key.Property} provided`);
            sql = sql.substring(0, sql.length - 1) + ") ";
            values = values.substring(0, values.length - 1) + ")";
            let insert = `${sql} ${values} ${returnKey};`;
            let retun = yield this._manager.ExecuteAsync(insert);
            if (key != undefined && retun.rows.length > 0) {
                obj[key.Property] = retun.rows[0][key.Column];
            }
            let subTypesUpdates = [];
            let updatableFields = [];
            let objectsToUpdate = [];
            let objectsToAdd = [];
            let buildSubupdates = [];
            for (let sub of subTypes) {
                let relation = SchemasDecorators_1.default.GetRelationAttribute(this._type, sub.Field);
                let subType = Type_1.default.GetDesingType(this._type, sub.Field);
                if (!subType && !relation)
                    throw new InvalidOperationException_1.default(`Can not determine the relation of the property ${this._type}.${sub.Field}`);
                if (!subType && relation) {
                    subType = relation.TypeBuilder();
                }
                let isArray = subType == Array;
                if (isArray) {
                    if (!relation)
                        continue;
                    subType = relation === null || relation === void 0 ? void 0 : relation.TypeBuilder();
                }
                let subObj = Reflect.get(obj, sub.Field);
                if (subObj == undefined)
                    continue;
                let subPK = SchemasDecorators_1.default.ExtractPrimaryKey(subType);
                if (subPK == undefined)
                    throw new InvalidOperationException_1.default(`The type ${subType.name} must have a primary key column`);
                let colletion = this._context.Collection(subType);
                if (key != undefined) {
                    for (let subKey of Type_1.default.GetProperties(subType)) {
                        let subRelation = SchemasDecorators_1.default.GetRelationAttribute(subType, subKey);
                        if (subRelation && subRelation.TypeBuilder() == this._type) {
                            if (subRelation.Field != undefined && subRelation.Field != sub.Field)
                                continue;
                            updatableFields.push(subKey);
                            if (subRelation.Relation == RelationType_1.RelationType.ONE_TO_MANY || subRelation.Relation == RelationType_1.RelationType.MANY_TO_MANY) {
                                if (isArray) {
                                    if (subObj == undefined || visiteds.indexOf(subObj) > -1)
                                        continue;
                                    for (let i of subObj) {
                                        if (i == undefined || visiteds.indexOf(i) > -1)
                                            continue;
                                        let metadata = Type_1.default.ExtractMetadata(i).filter(s => s.Field == subKey && s.Loaded);
                                        let value = [];
                                        if (metadata.length > 0) {
                                            value = ((_a = Reflect.get(i, subKey)) !== null && _a !== void 0 ? _a : []).filter(s => s[subPK] != obj[subPK]);
                                        }
                                        else {
                                            let item = yield colletion["Where"]({ Field: subPK, Value: Reflect.get(i, subPK) })["LoadRelationOn"](subKey)["FirstOrDefaultAsync"]();
                                            value = item == undefined ? [] : item[subKey];
                                            value = value !== null && value !== void 0 ? value : [];
                                        }
                                        value.push(obj);
                                        Reflect.set(i, subKey, value);
                                    }
                                }
                                else {
                                    if (subObj == undefined || visiteds.indexOf(subObj) > -1)
                                        continue;
                                    let metadata = Type_1.default.ExtractMetadata(subObj).filter(s => s.Field == subKey && s.Loaded);
                                    let value = [];
                                    if (metadata.length > 0) {
                                        value = ((_b = Reflect.get(subObj, subKey)) !== null && _b !== void 0 ? _b : []).filter(s => s[subPK] != obj[subPK]);
                                    }
                                    else {
                                        let item = yield colletion["Where"]({ Field: subPK, Value: Reflect.get(subObj, subPK) })["LoadRelationOn"](subKey)["FirstOrDefaultAsync"]();
                                        value = item == undefined ? [] : item[subKey];
                                        value = value !== null && value !== void 0 ? value : [];
                                    }
                                    value.push(obj);
                                    Reflect.set(subObj, subKey, value);
                                }
                            }
                            else {
                                if (subRelation.Relation == RelationType_1.RelationType.MANY_TO_ONE && isArray) {
                                    for (let i of subObj) {
                                        if (i == undefined || visiteds.indexOf(i) > -1)
                                            continue;
                                        Reflect.set(i, subKey, obj);
                                    }
                                }
                                else {
                                    if (subObj == undefined || visiteds.indexOf(subObj) > -1)
                                        continue;
                                    Reflect.set(subObj, subKey, obj);
                                }
                            }
                        }
                    }
                }
                if (isArray) {
                    if (subObj == undefined)
                        continue;
                    for (let i of subObj) {
                        if (i == undefined)
                            continue;
                        if (!Type_1.default.HasValue(Reflect.get(i, subPK))) {
                            if (cascade || relations.filter(s => s == sub.Field).length > 0) {
                                let cs = objectsToAdd.filter(s => s.Type == subType);
                                if (cs.length == 0)
                                    objectsToAdd.push({ Objs: [i], Type: subType, SubPK: subPK });
                                else
                                    cs[0].Objs.push(i);
                            }
                        }
                        else {
                            let cs = objectsToUpdate.filter(s => s.Type == subType);
                            if (cs.length == 0)
                                objectsToUpdate.push({ Objs: [{ Obj: i, UpdatableFields: updatableFields }], Type: subType, SubPK: subPK });
                            else {
                                let ccs = cs.filter(s => s.Objs.filter(j => j.Obj == i).length > 0);
                                if (ccs.length == 0) {
                                    cs[0].Objs.push({ Obj: i, UpdatableFields: updatableFields });
                                }
                                else {
                                    ccs[0].Objs[0].UpdatableFields.push(...updatableFields);
                                }
                            }
                        }
                    }
                }
                else {
                    if (subObj == undefined)
                        continue;
                    if (!Type_1.default.HasValue(Reflect.get(subObj, subPK))) {
                        if (cascade || relations.filter(s => s == sub.Field).length > 0) {
                            let cs = objectsToAdd.filter(s => s.Type == subType);
                            if (cs.length == 0)
                                objectsToAdd.push({ Objs: [subObj], Type: subType, SubPK: subPK });
                            else
                                cs[0].Objs.push(subObj);
                        }
                    }
                    else {
                        let cs = objectsToUpdate.filter(s => s.Type == subType);
                        if (cs.length == 0)
                            objectsToUpdate.push({ Objs: [{ Obj: subObj, UpdatableFields: updatableFields }], Type: subType, SubPK: subPK });
                        else {
                            let ccs = cs.filter(s => s.Objs.filter(j => j.Obj == subObj).length > 0);
                            if (ccs.length == 0) {
                                cs[0].Objs.push({ Obj: subObj, UpdatableFields: updatableFields });
                            }
                            else {
                                ccs[0].Objs[0].UpdatableFields.push(...updatableFields);
                            }
                        }
                    }
                }
                buildSubupdates.push(() => {
                    let spk = SchemasDecorators_1.default.ExtractPrimaryKey(subType);
                    let columnType = Type_1.default.CastType(Type_1.default.GetDesingTimeTypeName(subType, spk));
                    if ((relation === null || relation === void 0 ? void 0 : relation.Relation) == RelationType_1.RelationType.MANY_TO_MANY || (relation === null || relation === void 0 ? void 0 : relation.Relation) == RelationType_1.RelationType.ONE_TO_MANY || isArray)
                        columnType = Type_1.default.AsArray(columnType);
                    if (subObj == undefined)
                        return;
                    let updateValues = [Reflect.get(subObj, spk)];
                    if (isArray) {
                        updateValues = [];
                        for (let i of subObj) {
                            if (i == undefined)
                                continue;
                            updateValues.push(Reflect.get(i, spk));
                        }
                    }
                    Type_1.default.InjectMetadata(obj, {
                        Field: sub.Field,
                        Type: columnType,
                        Value: updateValues,
                        Loaded: true
                    });
                    subTypesUpdates.push(`"${sub.Column}" = ${this.CreateValueStatement(columnType, isArray ? updateValues : updateValues[0])}`);
                });
            }
            objectsToAdd.forEach(o => {
                o.Objs = o.Objs.filter((i, ix, s) => {
                    return ix == s.findIndex(v => v == i);
                });
            });
            for (let cs of objectsToAdd) {
                let colletion = this._context.Collection(cs.Type);
                for (let i of cs.Objs)
                    yield colletion["AddObjectAsync"](i, true, [], visiteds);
            }
            for (let cs of objectsToUpdate) {
                let colletion = this._context.Collection(cs.Type);
                for (let i of cs.Objs)
                    yield colletion["UpdateObjectAsync"](i.Obj, false, (_c = i.UpdatableFields) !== null && _c !== void 0 ? _c : [], [], visiteds);
            }
            for (let b of buildSubupdates)
                b();
            if (subTypesUpdates.length > 0) {
                let subUpdate = `update "${Type_1.default.GetTableName(this._type)}" set `;
                for (let p of subTypesUpdates) {
                    subUpdate += `${p},`;
                }
                subUpdate = `${subUpdate.substring(0, subUpdate.length - 1)} where `;
                subUpdate += this.EvaluateStatement({
                    StatementType: StatementType.WHERE,
                    Statement: {
                        Field: key.Property,
                        Kind: myorm_core_1.Operation.EQUALS,
                        Value: Reflect.get(obj, key.Property)
                    }
                });
                yield this._manager.ExecuteNonQueryAsync(subUpdate);
            }
            return obj;
        }));
    }
    UpdateSelectionAsync() {
        return this.CreatePromisse(() => __awaiter(this, void 0, void 0, function* () {
            if (!this._set || this._set.Get().length == 0)
                throw new InvalidOperationException_1.default('Can not realize a update with no one set operation before');
            let setters = this._set.Get();
            let update = `update "${this._table}" set`;
            let values = "";
            let whereSrt = PGSetHelper_1.default.ExtractWhereData(this);
            if (!whereSrt) {
                if (this._whereAsString != undefined && this._statements.length > 0) {
                    throw new InvalidOperationException_1.default("Is not possible combine free and structured queries");
                }
                if (this._whereAsString != undefined) {
                    whereSrt = ` ${this._whereAsString} `;
                }
                whereSrt = this.EvaluateWhere();
            }
            let PK = SchemasDecorators_1.default.ExtractPrimaryKey(this._type);
            if (!PK)
                throw new InvalidOperationException_1.default(`The type ${this._type.name} must have a primary key field`);
            let pkColumn = Type_1.default.GetColumnNameAndType(this._type).filter(s => s.Field == PK)[0];
            for (let map of this._maps) {
                let set = setters.filter(s => s.Key == map.Field);
                if (set.length == 0)
                    continue;
                if (SchemasDecorators_1.default.IsPrimaryKey(this._type, map.Field))
                    continue;
                if (set[0].Value == undefined || set[0].Value == null) {
                    values += `"${map.Column}" = null`;
                    continue;
                }
                let designType = Type_1.default.GetDesingType(this._type, map.Field);
                let relation = SchemasDecorators_1.default.GetRelationAttribute(this._type, map.Field);
                let subType = Type_1.default.GetDesingType(this._type, map.Field);
                if (!subType && !relation)
                    throw new InvalidOperationException_1.default(`Can not determine the relation of the property ${this._type}.${map.Field}`);
                let isArray = subType == Array;
                if (!subType && relation)
                    subType = relation.TypeBuilder();
                if (isArray) {
                    if (!relation)
                        continue;
                    subType = relation === null || relation === void 0 ? void 0 : relation.TypeBuilder();
                }
                let subPK = SchemasDecorators_1.default.ExtractPrimaryKey(subType);
                if ((designType && this._context.IsMapped(designType)) || (relation && this._context.IsMapped(relation.TypeBuilder()))) {
                    if (subPK == undefined)
                        throw new InvalidOperationException_1.default(`The type ${subType.name} must have a primary key column`);
                    let colletion = this._context.Collection(subType);
                    if (isArray) {
                        for (let i of set[0].Value) {
                            if (i == undefined)
                                continue;
                            if (!Type_1.default.HasValue(Reflect.get(i, subPK)))
                                yield colletion["AddAsync"](i);
                            if (relation) {
                                let subRelation;
                                for (let c of Type_1.default.GetColumnNameAndType(subType)) {
                                    let r = SchemasDecorators_1.default.GetRelationAttribute(subType, c.Field);
                                    if (r && r.Field == set[0].Key && r.TypeBuilder() == this._type) {
                                        subRelation = r;
                                        break;
                                    }
                                }
                                if (subRelation && (subRelation.Relation == RelationType_1.RelationType.ONE_TO_MANY || (subRelation === null || subRelation === void 0 ? void 0 : subRelation.Relation) == RelationType_1.RelationType.MANY_TO_MANY)) {
                                    let subDesingType = Type_1.default.GetDesingType(subType, relation.Field);
                                    if (subDesingType == Array) {
                                        let subColumnName = Type_1.default.GetColumnNameAndType(subType).filter(s => s.Field == (relation === null || relation === void 0 ? void 0 : relation.Field))[0];
                                        let subTableName = Type_1.default.GetTableName(subType);
                                        let subPkColumn = Type_1.default.GetColumnNameAndType(subType).filter(s => s.Field == subPK)[0];
                                        let queryAllpks = `(select array_agg(${pkColumn.Column}) from ${this._table} ${whereSrt})`;
                                        let subUpdate = `update ${subTableName} set ${subColumnName.Column} =  ${subColumnName.Column} || ${queryAllpks}  where "${subPkColumn.Column}" = ${this.CreateValueStatement(Type_1.default.CastType(subPkColumn.Type), Reflect.get(i, subPK))}`;
                                        yield this._manager.ExecuteNonQueryAsync(subUpdate);
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if (set[0].Value == undefined)
                            continue;
                        if (!Type_1.default.HasValue(Reflect.get(set[0].Value, subPK)))
                            yield colletion["AddAsync"](set[0].Value);
                        if (relation) {
                            let subRelation;
                            for (let c of Type_1.default.GetColumnNameAndType(subType)) {
                                let r = SchemasDecorators_1.default.GetRelationAttribute(subType, c.Field);
                                if (r && r.Field == set[0].Key && r.TypeBuilder() == this._type) {
                                    subRelation = r;
                                    break;
                                }
                            }
                            if (subRelation && (subRelation.Relation == RelationType_1.RelationType.ONE_TO_MANY || (subRelation === null || subRelation === void 0 ? void 0 : subRelation.Relation) == RelationType_1.RelationType.MANY_TO_MANY)) {
                                let subDesingType = Type_1.default.GetDesingType(subType, relation.Field);
                                if (subDesingType == Array) {
                                    let subColumnName = Type_1.default.GetColumnNameAndType(subType).filter(s => s.Field == (relation === null || relation === void 0 ? void 0 : relation.Field))[0];
                                    let subTableName = Type_1.default.GetTableName(subType);
                                    let subPkColumn = Type_1.default.GetColumnNameAndType(subType).filter(s => s.Field == subPK)[0];
                                    let queryAllpks = `(select array_agg(${pkColumn.Column}) from ${this._table} ${whereSrt})`;
                                    let subUpdate = `update ${subTableName} set ${subColumnName.Column} =  ${subColumnName.Column} || ${queryAllpks}  where "${subPkColumn.Column}" = ${this.CreateValueStatement(Type_1.default.CastType(subPkColumn.Type), Reflect.get(set[0].Value, subPK))}`;
                                    yield this._manager.ExecuteNonQueryAsync(subUpdate);
                                }
                            }
                        }
                    }
                    let columnType = Type_1.default.CastType(Type_1.default.GetDesingTimeTypeName(subType, subPK));
                    if ((relation === null || relation === void 0 ? void 0 : relation.Relation) == RelationType_1.RelationType.MANY_TO_MANY || (relation === null || relation === void 0 ? void 0 : relation.Relation) == RelationType_1.RelationType.ONE_TO_MANY)
                        columnType = Type_1.default.AsArray(columnType);
                    let updateValues = [Reflect.get(set[0].Value, subPK)];
                    if (isArray) {
                        updateValues = [];
                        for (let i of set[0].Value) {
                            if (i == undefined)
                                continue;
                            updateValues.push(Reflect.get(i, subPK));
                        }
                    }
                    values += `"${map.Column}" = ${this.CreateValueStatement(columnType, isArray ? updateValues : updateValues[0])},`;
                }
                else {
                    let colType = Type_1.default.CastType(map.Type);
                    if (SchemasDecorators_1.default.IsPrimaryKey(this._type, map.Field))
                        continue;
                    values += `"${map.Column}" = ${this.CreateValueStatement(colType, set[0].Value)},`;
                }
            }
            update = `${update} ${values.substring(0, values.length - 1)}`;
            update += " " + whereSrt;
            yield this._manager.ExecuteNonQueryAsync(update);
        }));
    }
    Set(key, value) {
        this._set.Add(key, value);
        return this;
    }
    UpdateAsync(obj) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.UpdateObjectAsync(obj, true);
        });
    }
    UpdateObjectAndRelationsAsync(obj, relations) {
        return __awaiter(this, void 0, void 0, function* () {
            Type_1.default.DeleteMetadata(obj);
            return this.UpdateObjectAsync(obj, false, relations ? relations.map(s => s.toString()) : []);
        });
    }
    UpdateObjectAsync(obj, cascade, relationsAllowed, fieldsAllowed, visiteds = []) {
        return this.CreatePromisse(() => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            relationsAllowed = relationsAllowed !== null && relationsAllowed !== void 0 ? relationsAllowed : [];
            visiteds = visiteds !== null && visiteds !== void 0 ? visiteds : [];
            if (visiteds.indexOf(obj) > -1)
                return obj;
            if (!this.IsCorrectType(obj))
                throw new InvalidOperationException_1.default(`The object passed as argument is not a ${this._type.name} instance`);
            if (!obj)
                throw new InvalidOperationException_1.default(`Cannot update a null reference object of ${this._type.name}`);
            let keys = Type_1.default.GetProperties(this._type).filter(p => SchemasDecorators_1.default.IsPrimaryKey(this._type, p));
            let wheres = [];
            if (keys && keys.length > 0) {
                keys.forEach((w, i) => {
                    let keyValue = Reflect.get(obj, w);
                    if (!keyValue)
                        throw new ConstraintFailException_1.default(`The field ${this._type.name}.${w} is a primary key but has no value`);
                    wheres.push({
                        Statement: {
                            Field: w,
                            Kind: myorm_core_1.Operation.EQUALS,
                            Value: Reflect.get(obj, w)
                        },
                        StatementType: i == 0 ? StatementType.WHERE : StatementType.AND
                    });
                });
            }
            let update = `update "${this._table}" set`;
            let values = "";
            let key;
            let subTypes = [];
            for (let map of this._maps) {
                let designType = Type_1.default.GetDesingType(this._type, map.Field);
                let relation = SchemasDecorators_1.default.GetRelationAttribute(this._type, map.Field);
                if ((designType && this._context.IsMapped(designType)) || (relation && this._context.IsMapped(relation.TypeBuilder()))) {
                    subTypes.push({
                        Column: map.Column,
                        Field: map.Field,
                        Type: map.Type
                    });
                    continue;
                }
                let colType = Type_1.default.CastType(map.Type);
                if (SchemasDecorators_1.default.IsPrimaryKey(this._type, map.Field)) {
                    key =
                        {
                            Column: map.Column,
                            Property: map.Field
                        };
                    continue;
                }
                if (fieldsAllowed && fieldsAllowed.length > 0 && fieldsAllowed.filter(s => s == map.Column).length == 0)
                    continue;
                values += `"${map.Column}" = ${this.CreateValueStatement(colType, Reflect.get(obj, map.Field))},`;
            }
            if (key == undefined)
                throw new InvalidOperationException_1.default(`The type ${this._type.name} must have a primary key column`);
            if (visiteds.filter(s => s && s.constructor == obj.constructor && Reflect.get(s, key.Property) == Reflect.get(obj, key.Property)).length > 0)
                return obj;
            visiteds.push(obj);
            update = `${update} ${values.substring(0, values.length - 1)}`;
            for (let where of wheres) {
                update += ` ${where.StatementType} ${this.EvaluateStatement(where)} `;
            }
            if (values.trim().length > 1)
                yield this._manager.ExecuteNonQueryAsync(update);
            let subTypesUpdates = [];
            let objectsToUpdate = [];
            let objectsToAdd = [];
            let buildSubupdates = [];
            let updatableFields = [];
            for (let sub of subTypes) {
                let subObj = Reflect.get(obj, sub.Field);
                let metadata = Type_1.default.ExtractMetadata(obj);
                let meta = metadata.filter(s => s.Field == sub.Field && s.Loaded);
                let objetsToRemoveThisReferece = { HasRelation: false, IsArray: false, SubIsArray: false, SubField: "", Relation: undefined, SubRelation: undefined };
                if (((meta.length > 0 && meta[0].Loaded) || relationsAllowed.filter(s => s == sub.Field).length > 0) && subObj == undefined) {
                    subTypesUpdates.push(`"${sub.Column}" = null`);
                }
                if (meta.length == 0 && relationsAllowed.filter(s => s == sub.Field).length == 0)
                    continue;
                let relation = SchemasDecorators_1.default.GetRelationAttribute(this._type, sub.Field);
                let subType = Type_1.default.GetDesingType(this._type, sub.Field);
                if (!subType && !relation)
                    throw new InvalidOperationException_1.default(`Can not determine the relation of the property ${this._type}.${sub.Field}`);
                if (!subType && relation) {
                    subType = relation.TypeBuilder();
                }
                let isArray = subType == Array;
                if (isArray) {
                    if (!relation)
                        continue;
                    subType = relation === null || relation === void 0 ? void 0 : relation.TypeBuilder();
                }
                if ((!cascade) && relationsAllowed.filter(s => s == sub.Field).length == 0 && this.GetChanges(meta, subObj, subType).length == 0)
                    continue;
                if (meta.length > 0)
                    relationsAllowed.push(meta[0].Field);
                let subPK = SchemasDecorators_1.default.ExtractPrimaryKey(subType);
                if (subPK == undefined)
                    throw new InvalidOperationException_1.default(`The type ${subType.name} must have a primary key column`);
                if (key == undefined)
                    throw new InvalidOperationException_1.default(`The type ${this._type.name} must have a primary key column`);
                let hasSubrelation = false;
                if (key != undefined) {
                    let colletion = this._context.Collection(subType);
                    for (let subKey of Type_1.default.GetProperties(subType)) {
                        let subRelation = SchemasDecorators_1.default.GetRelationAttribute(subType, subKey);
                        if (subRelation && subRelation.TypeBuilder() == this._type) {
                            if (subRelation.Field != undefined && subRelation.Field != sub.Field)
                                continue;
                            updatableFields.push(subKey);
                            objetsToRemoveThisReferece.HasRelation = true;
                            objetsToRemoveThisReferece.Relation = relation;
                            objetsToRemoveThisReferece.SubRelation = subRelation;
                            objetsToRemoveThisReferece.SubField = subKey;
                            hasSubrelation = true;
                            if (subRelation.Relation == RelationType_1.RelationType.ONE_TO_MANY || subRelation.Relation == RelationType_1.RelationType.MANY_TO_MANY) {
                                let subFKTypeIsArray = Type_1.default.GetDesingType(subType, subKey) == Array;
                                objetsToRemoveThisReferece.IsArray = isArray;
                                objetsToRemoveThisReferece.SubIsArray = subFKTypeIsArray;
                                if (subObj == undefined || visiteds.indexOf(subObj) > -1)
                                    continue;
                                if (isArray) {
                                    if (subObj == undefined)
                                        continue;
                                    for (let i of subObj) {
                                        if (i == undefined || visiteds.indexOf(i) > -1)
                                            continue;
                                        if (subFKTypeIsArray) {
                                            let value = [];
                                            let subMeta = Type_1.default.ExtractMetadata(i);
                                            if (subMeta.length > 0 && subMeta.filter(s => s.Field == subKey && s.Loaded).length > 0) {
                                                value = ((_a = Reflect.get(i, subKey)) !== null && _a !== void 0 ? _a : []).filter(s => s[subPK] != obj[subPK]);
                                            }
                                            else {
                                                let item = yield colletion["Where"]({ Field: subPK, Value: Reflect.get(i, subPK) })["LoadRelationOn"](subKey)["FirstOrDefaultAsync"]();
                                                value = item == undefined ? [] : item[subKey];
                                                value = value !== null && value !== void 0 ? value : [];
                                            }
                                            value = value.filter(s => Reflect.get(s, key.Property) != Reflect.get(obj, key.Property));
                                            value.push(obj);
                                            Reflect.set(i, subKey, value);
                                        }
                                        else {
                                            Reflect.set(i, subKey, obj);
                                        }
                                    }
                                }
                                else {
                                    if (subObj == undefined || visiteds.indexOf(subObj) > -1)
                                        continue;
                                    if (subFKTypeIsArray) {
                                        let value = [];
                                        let subMeta = Type_1.default.ExtractMetadata(subObj);
                                        if (subMeta.length > 0 && subMeta.filter(s => s.Field == subKey && s.Loaded).length > 0) {
                                            value = ((_b = Reflect.get(subObj, subKey)) !== null && _b !== void 0 ? _b : []).filter(s => s[subPK] != obj[subPK]);
                                        }
                                        else {
                                            let item = yield colletion["Where"]({ Field: subPK, Value: Reflect.get(subObj, subPK) })["LoadRelationOn"](subKey)["FirstOrDefaultAsync"]();
                                            value = item == undefined ? [] : item[subKey];
                                            value = value !== null && value !== void 0 ? value : [];
                                        }
                                        value = value.filter(s => Reflect.get(s, key.Property) != Reflect.get(obj, key.Property));
                                        value.push(obj);
                                        Reflect.set(subObj, subKey, value);
                                    }
                                    else {
                                        Reflect.set(subObj, subKey, obj);
                                    }
                                }
                            }
                            else {
                                if (subObj == undefined || visiteds.indexOf(subObj) > -1)
                                    continue;
                                if (subRelation.Relation == RelationType_1.RelationType.MANY_TO_ONE) {
                                    for (let i of subObj) {
                                        if (i == undefined || visiteds.indexOf(i) > -1)
                                            continue;
                                        Reflect.set(i, subKey, obj);
                                    }
                                }
                                else {
                                    Reflect.set(subObj, subKey, obj);
                                }
                            }
                        }
                    }
                }
                let colletion = this._context.Collection(subType);
                if ((cascade || relationsAllowed.filter(s => s == sub.Field).length > 0))
                    if (meta.length > 0 && objetsToRemoveThisReferece.HasRelation) {
                        let v = meta[0].Value;
                        let changes = this.GetChanges(meta, subObj, subType);
                        if (v instanceof Array)
                            meta[0].Value = meta[0].Value.filter((s) => changes.indexOf(s) == -1);
                        else if (v == changes[0])
                            meta[0].Loaded = false;
                        for (let c of changes) {
                            let item = yield colletion["Where"]({ Field: subPK, Value: c })["LoadRelationOn"](objetsToRemoveThisReferece.SubField)["FirstOrDefaultAsync"]();
                            if (item) {
                                if (objetsToRemoveThisReferece.SubIsArray) {
                                    item[objetsToRemoveThisReferece.SubField] =
                                        item[objetsToRemoveThisReferece.SubField].filter(s => s && Reflect.get(s, key.Property) != Reflect.get(obj, key.Property));
                                }
                                else if (((_c = objetsToRemoveThisReferece.SubRelation) === null || _c === void 0 ? void 0 : _c.Relation) != RelationType_1.RelationType.ONE_TO_MANY) {
                                    item[objetsToRemoveThisReferece.SubField] = undefined;
                                }
                                yield colletion["UpdateObjectAsync"](item, false, [], [], visiteds);
                            }
                        }
                    }
                if (isArray) {
                    if (subObj == undefined)
                        continue;
                    for (let i of subObj) {
                        if (i == undefined)
                            continue;
                        if (!Type_1.default.HasValue(Reflect.get(i, subPK))) {
                            let cs = objectsToAdd.filter(s => s.Type == subType);
                            if (cs.length == 0)
                                objectsToAdd.push({ Objs: [i], Type: subType, SubPK: subPK });
                            else
                                cs[0].Objs.push(i);
                        }
                        else if ((cascade || relationsAllowed.filter(s => s == sub.Field).length > 0)) {
                            let cs = objectsToUpdate.filter(s => s.Type == subType);
                            if (cs.length == 0)
                                objectsToUpdate.push({ Objs: [{ Obj: i, UpdatableFields: updatableFields }], Type: subType, SubPK: subPK });
                            else {
                                let ccs = cs.filter(s => s.Objs.filter(j => j.Obj == i).length > 0);
                                if (ccs.length == 0) {
                                    cs[0].Objs.push({ Obj: i, UpdatableFields: updatableFields });
                                }
                                else {
                                    ccs[0].Objs[0].UpdatableFields.push(...updatableFields);
                                }
                            }
                        }
                    }
                }
                else {
                    if (subObj == undefined)
                        continue;
                    if (!Type_1.default.HasValue(Reflect.get(subObj, subPK))) {
                        let cs = objectsToAdd.filter(s => s.Type == subType);
                        if (cs.length == 0)
                            objectsToAdd.push({ Objs: [subObj], Type: subType, SubPK: subPK });
                        else
                            cs[0].Objs.push(subObj);
                    }
                    else if ((cascade || relationsAllowed.filter(s => s == sub.Field).length > 0)) {
                        let cs = objectsToUpdate.filter(s => s.Type == subType);
                        if (cs.length == 0)
                            objectsToUpdate.push({ Objs: [{ Obj: subObj, UpdatableFields: updatableFields }], Type: subType, SubPK: subPK });
                        else {
                            let ccs = cs.filter(s => s.Objs.filter(j => j.Obj == subObj).length > 0);
                            if (ccs.length == 0) {
                                cs[0].Objs.push({ Obj: subObj, UpdatableFields: updatableFields });
                            }
                            else {
                                ccs[0].Objs[0].UpdatableFields.push(...updatableFields);
                            }
                        }
                    }
                }
                buildSubupdates.push(() => {
                    let spk = SchemasDecorators_1.default.ExtractPrimaryKey(subType);
                    let columnType = Type_1.default.CastType(Type_1.default.GetDesingTimeTypeName(subType, spk));
                    if ((relation === null || relation === void 0 ? void 0 : relation.Relation) == RelationType_1.RelationType.MANY_TO_MANY || (relation === null || relation === void 0 ? void 0 : relation.Relation) == RelationType_1.RelationType.ONE_TO_MANY || isArray)
                        columnType = Type_1.default.AsArray(columnType);
                    if (subObj == undefined)
                        return;
                    let updateValues = [Reflect.get(subObj, spk)];
                    if (isArray) {
                        updateValues = [];
                        for (let i of subObj) {
                            if (i == undefined)
                                continue;
                            updateValues.push(Reflect.get(i, spk));
                        }
                    }
                    Type_1.default.InjectMetadata(obj, {
                        Field: sub.Field,
                        Type: columnType,
                        Value: updateValues,
                        Loaded: true
                    });
                    subTypesUpdates.push(`"${sub.Column}" = ${this.CreateValueStatement(columnType, isArray ? updateValues : updateValues[0])}`);
                });
            }
            objectsToAdd.forEach(o => {
                o.Objs = o.Objs.filter((i, ix, s) => {
                    return ix == s.findIndex(v => v == i);
                });
            });
            for (let cs of objectsToAdd) {
                let colletion = this._context.Collection(cs.Type);
                for (let i of cs.Objs)
                    yield colletion["AddObjectAsync"](i, true, [], visiteds);
            }
            for (let cs of objectsToUpdate) {
                let colletion = this._context.Collection(cs.Type);
                for (let i of cs.Objs)
                    yield colletion["UpdateObjectAsync"](i.Obj, false, (_d = i.UpdatableFields) !== null && _d !== void 0 ? _d : [], [], visiteds);
            }
            for (let b of buildSubupdates)
                b();
            if (subTypesUpdates.length > 0) {
                let subUpdate = `update "${Type_1.default.GetTableName(this._type)}" set `;
                for (let p of subTypesUpdates) {
                    subUpdate += `${p},`;
                }
                subUpdate = `${subUpdate.substring(0, subUpdate.length - 1)} where `;
                subUpdate += this.EvaluateStatement({
                    StatementType: StatementType.WHERE,
                    Statement: {
                        Field: key.Property,
                        Kind: myorm_core_1.Operation.EQUALS,
                        Value: Reflect.get(obj, key.Property)
                    }
                });
                yield this._manager.ExecuteNonQueryAsync(subUpdate);
            }
            return obj;
        }));
    }
    GetChanges(meta, subObj, subType) {
        let v = meta[0].Value;
        let subPK = SchemasDecorators_1.default.ExtractPrimaryKey(subType);
        let g = Reflect.get;
        if (v == undefined)
            return [];
        if (v instanceof Array && subObj instanceof Array)
            if (v.length == 0 || v.every(s => subObj.find(u => g(u, subPK) == s)))
                return [];
            else
                return v.filter(s => !subObj.find(u => g(u, subPK) == s));
        if (v instanceof Array && subObj == undefined)
            return v;
        if (v && subObj == undefined)
            return [v];
        if (v != g(subObj, subPK))
            return [v];
        return [];
    }
    DeleteSelectionAsync() {
        return this.CreatePromisse(() => __awaiter(this, void 0, void 0, function* () {
            let whereSrt = PGSetHelper_1.default.ExtractWhereData(this);
            let query = `delete from "${this._table}"`;
            if (!whereSrt) {
                if (this._whereAsString != undefined && this._statements.length > 0) {
                    throw new InvalidOperationException_1.default("Is not possible combine free and structured queries");
                }
                if (this._whereAsString != undefined) {
                    query += ` ${this._whereAsString} `;
                }
                query += this.EvaluateWhere();
            }
            else {
                query += whereSrt;
            }
            yield this._manager.ExecuteNonQueryAsync(query);
        }));
    }
    DeleteAsync(obj) {
        return this.CreatePromisse(() => __awaiter(this, void 0, void 0, function* () {
            if (!obj)
                throw new InvalidOperationException_1.default(`Cannot delete a null reference object of ${this._type.name}`);
            if (!this.IsCorrectType(obj))
                throw new InvalidOperationException_1.default(`The object passed as argument is not a ${this._type.name} instance`);
            let keys = Type_1.default.GetProperties(this._type).filter(p => SchemasDecorators_1.default.IsPrimaryKey(this._type, p));
            let wheres = [];
            if (keys && keys.length > 0) {
                keys.forEach((w, i) => {
                    wheres.push({
                        Statement: {
                            Field: w,
                            Kind: myorm_core_1.Operation.EQUALS,
                            Value: Reflect.get(obj, w)
                        },
                        StatementType: i == 0 ? StatementType.WHERE : StatementType.AND
                    });
                });
            }
            let del = `delete from "${this._table}" `;
            for (let where of wheres) {
                del += ` ${where.StatementType} ${this.EvaluateStatement(where)} `;
            }
            yield this._manager.ExecuteNonQueryAsync(del);
            return obj;
        }));
    }
    Where(statement) {
        var _a;
        this._statements.push({
            Statement: {
                Field: statement.Field.toString(),
                Kind: (_a = statement.Kind) !== null && _a !== void 0 ? _a : myorm_core_1.Operation.EQUALS,
                Value: statement.Value
            },
            StatementType: StatementType.WHERE
        });
        return this;
    }
    And(statement) {
        var _a;
        this._statements.push({
            Statement: {
                Field: statement.Field.toString(),
                Kind: (_a = statement.Kind) !== null && _a !== void 0 ? _a : myorm_core_1.Operation.EQUALS,
                Value: statement.Value
            },
            StatementType: StatementType.AND
        });
        return this;
    }
    Or(statement) {
        var _a;
        this._statements.push({
            Statement: {
                Field: statement.Field.toString(),
                Kind: (_a = statement.Kind) !== null && _a !== void 0 ? _a : myorm_core_1.Operation.EQUALS,
                Value: statement.Value
            },
            StatementType: StatementType.OR
        });
        return this;
    }
    OrderBy(key) {
        this._ordering.push({
            Field: key,
            Order: OrderDirection.ASC
        });
        return this;
    }
    Join(key) {
        this._includes.push({
            Field: key
        });
        return this;
    }
    OrderDescendingBy(key) {
        this._ordering.push({
            Field: key,
            Order: OrderDirection.DESC
        });
        return this;
    }
    Limit(limit) {
        this._limit = limit >= 1 ? { Limit: limit } : undefined;
        return this;
    }
    Offset(offset) {
        this._offset = offset >= 1 ? { OffSet: offset } : undefined;
        return this;
    }
    Take(quantity) {
        return this.Limit(quantity);
    }
    CountAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.CreatePromisse(() => __awaiter(this, void 0, void 0, function* () {
                let whereSrt = PGSetHelper_1.default.ExtractWhereData(this);
                let sqlSrt = PGSetHelper_1.default.ExtractSQLData(this);
                let query = `select count(*) from "${this._table}"`;
                if (sqlSrt && sqlSrt.toLowerCase().trim().startsWith(`select distinct "${this._table}".*`)) {
                    query = sqlSrt;
                }
                if (!whereSrt) {
                    if (this._whereAsString != undefined && this._statements.length > 0) {
                        throw new InvalidOperationException_1.default("Is not possible combine free and structured queries");
                    }
                    if (this._whereAsString != undefined) {
                        query += ` ${this._whereAsString} `;
                    }
                    query += this.EvaluateWhere();
                }
                else {
                    query += whereSrt;
                }
                let ordenation = "";
                for (let orderby of this._ordering) {
                    ordenation += `${this.EvaluateOrderBy(orderby)},`;
                }
                if (this._ordering.length > 0) {
                    query += ` order by ${ordenation.substring(0, ordenation.length - 1)}`;
                }
                if (this._offset != undefined) {
                    query += ` offset ${this._offset.OffSet}`;
                }
                if (this._limit != undefined) {
                    query += ` limit ${this._limit.Limit}`;
                }
                if (sqlSrt && sqlSrt.toLowerCase().trim().startsWith(`select distinct "${this._table}".*`)) {
                    query = `select count(*) from (${query}) as counter`;
                }
                var r = yield this._manager.ExecuteAsync(query);
                this.Reset();
                if (!r || r.rows.length == 0)
                    return 0;
                return Number.parseInt(r.rows[0].count);
            }));
        });
    }
    ToListAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.CreatePromisse(() => __awaiter(this, void 0, void 0, function* () {
                let whereSrt = PGSetHelper_1.default.ExtractWhereData(this);
                let sqlSrt = PGSetHelper_1.default.ExtractSQLData(this);
                let query = `select "${this._table}".* from "${this._table}"`;
                if (sqlSrt && sqlSrt.toLowerCase().trim().startsWith(`select distinct "${this._table}".*`))
                    query = sqlSrt;
                if (!whereSrt) {
                    if (this._whereAsString != undefined && this._statements.length > 0) {
                        throw new InvalidOperationException_1.default("Is not possible combine free and structured queries");
                    }
                    if (this._whereAsString != undefined) {
                        query += ` ${this._whereAsString} `;
                    }
                    query += this.EvaluateWhere();
                }
                else {
                    query += whereSrt;
                }
                let ordenation = "";
                for (let orderby of this._ordering) {
                    ordenation += `${this.EvaluateOrderBy(orderby)},`;
                }
                if (this._ordering.length > 0) {
                    query += ` order by ${ordenation.substring(0, ordenation.length - 1)}`;
                }
                if (this._offset != undefined) {
                    query += ` offset ${this._offset.OffSet}`;
                }
                if (this._limit != undefined) {
                    query += ` limit ${this._limit.Limit}`;
                }
                var r = yield this._manager.ExecuteAsync(query);
                if (r.rows.length == 0) {
                    this.Reset();
                    return [];
                }
                let list = [];
                list = yield this.BuildObjects(r);
                this.Reset();
                return list;
            }));
        });
    }
    FirstOrDefaultAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.CreatePromisse(() => __awaiter(this, void 0, void 0, function* () {
                let rows = yield this.Limit(1).ToListAsync();
                if (rows && rows.length > 0)
                    return rows[0];
                return undefined;
            }));
        });
    }
    WhereField(field) {
        this.ResetFilters();
        return new PGFluentField_1.default(this, field, false);
    }
    AndField(field) {
        return new PGFluentField_1.default(this, field, false);
    }
    OrField(field) {
        return new PGFluentField_1.default(this, field, true);
    }
    WhereAsString(where) {
        this.ResetFilters();
        if (where && !where.trim().toLocaleLowerCase().startsWith("where")) {
            where = `where ${where}`;
        }
        this._whereAsString = where;
        return this;
    }
    LoadRelationOn(field) {
        return this.Join(field);
    }
    CreatePromisse(func) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            try {
                resolve(yield func());
            }
            catch (err) {
                reject(err);
            }
            finally {
                this.Reset();
            }
        }));
    }
    CleanQueryTree() {
        this.Reset();
    }
    CreateValueStatement(colType, value) {
        if (value == undefined || value == null)
            return 'null';
        if (colType == DBTypes_1.DBTypes.TEXT) {
            return `$$${value}$$`;
        }
        else if (colType == DBTypes_1.DBTypes.BOOLEAN) {
            return `${value.toString().toLowerCase()}`;
        }
        else if (Type_1.default.IsNumber(colType)) {
            if (isNaN(value))
                throw new InvalidOperationException_1.default(`Can not cast the value "${value}" in a number`);
            return `${value}`.replace(',', '.');
        }
        else if (Type_1.default.IsDate(colType)) {
            let dt;
            if (value.constructor == Date)
                dt = value;
            else
                dt = new Date(value.toString());
            if (!dt)
                throw new InvalidOperationException_1.default(`Can not cast the value: "${value}" in a valid date`);
            let dtStr = `${dt.getFullYear()}-${dt.getMonth() + 1}-${dt.getDate()}`;
            if (colType == DBTypes_1.DBTypes.DATE) {
                return `'${dtStr}'::date`;
            }
            else {
                return `'${dtStr} ${dt.getHours()}:${dt.getMinutes()}'::timestamp`;
            }
        }
        else if (Type_1.default.IsArray(colType)) {
            let valuesStr = 'array[';
            let elementType = Type_1.default.ExtractElementType(colType);
            let hasItens = false;
            for (let i of value) {
                hasItens = true;
                valuesStr += `${this.CreateValueStatement(elementType, i)},`;
            }
            if (hasItens)
                valuesStr = valuesStr.substring(0, valuesStr.length - 1);
            valuesStr += `]::${this._manager["CastToPostgreSQLType"](colType)}`;
            return valuesStr;
        }
        throw new TypeNotSuportedException_1.default(`The type ${colType} is not suported`);
    }
    EvaluateWhere() {
        let query = "";
        for (let i = 0; i < this._statements.length; i++) {
            let where = this._statements[i];
            if (i == 0 && where.StatementType != StatementType.WHERE)
                throw new InvalidOperationException_1.default(`The query three must start with a WHERE statement`);
            if (i > 0 && where.StatementType == StatementType.WHERE)
                where.StatementType = StatementType.AND;
            query += ` ${where.StatementType} ${this.EvaluateStatement(where)} `;
        }
        return query;
    }
    EvaluateStatement(pgStatement) {
        let column = Type_1.default.GetColumnName(this._type, pgStatement.Statement.Field.toString());
        let typeName = Type_1.default.GetDesingTimeTypeName(this._type, pgStatement.Statement.Field.toString());
        let operation = this.GetOperators(pgStatement.Statement.Kind);
        let type = Type_1.default.GetDesingType(this._type, pgStatement.Statement.Field.toString());
        let isArray = type == Array;
        let relation = SchemasDecorators_1.default.GetRelationAttribute(this._type, pgStatement.Statement.Field.toString());
        if (!type) {
            if (!relation) {
                throw new InvalidOperationException_1.default(`Can not determine the correct type conversion for propety ${pgStatement.Statement.Field.toString()}`);
            }
            type = relation.TypeBuilder();
        }
        if (pgStatement.Statement.Value == undefined)
            return `"${this._table}".${column} is null`;
        if (this._context.IsMapped(type) || (relation && this._context.IsMapped(relation.TypeBuilder()))) {
            if (!relation)
                throw new InvalidOperationException_1.default(`Can not determine the correct type conversion for propety ${pgStatement.Statement.Field.toString()}`);
            if (isArray) {
                if (pgStatement.Statement.Value.lenght == 0)
                    return `coalesce(array_length("${this._table}".${column}, 1), 0) = 0`;
                if (pgStatement.Statement.Value.filter(s => s == undefined || s == null).length > 0)
                    throw new InvalidOperationException_1.default(`Can not compare relations with null or undefined objets`);
                let c = pgStatement.Statement.Value[0];
                let k = SchemasDecorators_1.default.ExtractPrimaryKey(c.constructor);
                if (!k)
                    throw new ConstraintFailException_1.default(`The type ${c.constructor.name} must have a key field`);
                let elementType = Type_1.default.GetDesingTimeTypeName(c.constructor, k);
                let internalType = Type_1.default.CastType(elementType);
                let keyType = Type_1.default.AsArray(internalType);
                let newValues = [];
                for (let e of pgStatement.Statement.Value) {
                    newValues = [e[k]];
                }
                typeName = keyType;
                pgStatement.Statement.Value = newValues;
            }
            else {
                let k = SchemasDecorators_1.default.ExtractPrimaryKey(pgStatement.Statement.Value.constructor);
                if (!k)
                    throw new ConstraintFailException_1.default(`The type ${pgStatement.Statement.Value.constructor.name} must have a key field`);
                let elementType = Type_1.default.GetDesingTimeTypeName(pgStatement.Statement.Value.constructor, k);
                let internalType = Type_1.default.CastType(elementType);
                typeName = internalType;
                pgStatement.Statement.Value = pgStatement.Statement.Value[k];
            }
        }
        if (isArray) {
            if (!typeName)
                throw new InvalidOperationException_1.default(`Can not determine the correct type conversion for propety ${pgStatement.Statement.Field.toString()}`);
            if (pgStatement.Statement.Kind == myorm_core_1.Operation.EQUALS) {
                return `"${this._table}".${column} = ${this.CreateValueStatement(typeName, pgStatement.Statement.Value)}`;
            }
            if (pgStatement.Statement.Kind == myorm_core_1.Operation.NOTEQUALS) {
                return `"${this._table}".${column} != ${this.CreateValueStatement(typeName, pgStatement.Statement.Value)}`;
            }
            if (pgStatement.Statement.Kind == myorm_core_1.Operation.SMALLER || pgStatement.Statement.Kind == myorm_core_1.Operation.SMALLEROREQUALS) {
                return `"${this._table}".${column} <@ ${this.CreateValueStatement(typeName, pgStatement.Statement.Value)}`;
            }
            if ([myorm_core_1.Operation.STARTWITH, myorm_core_1.Operation.CONSTAINS, myorm_core_1.Operation.ENDWITH, myorm_core_1.Operation.GREATHER, myorm_core_1.Operation.GREATHEROREQUALS].includes(pgStatement.Statement.Kind)) {
                return `"${this._table}".${column} @> ${this.CreateValueStatement(typeName, pgStatement.Statement.Value)}`;
            }
        }
        if (Type_1.default.IsNumber(Type_1.default.CastType(typeName.toString())) || Type_1.default.IsDate(Type_1.default.CastType(typeName.toString()))) {
            operation[1] = "";
            operation[2] = "";
            if (Type_1.default.IsDate(Type_1.default.CastType(typeName.toString()))) {
                let dt = pgStatement.Statement.Value;
                if (!dt)
                    throw new InvalidOperationException_1.default(`Can not cast the value: "${pgStatement.Statement.Value}" in a valid date`);
                let dtStr = `${dt.getFullYear()}-${dt.getMonth() + 1}-${dt.getDate()}`;
                if (Type_1.default.CastType(typeName.toString()) == DBTypes_1.DBTypes.DATE) {
                    pgStatement.Statement.Value = `'${dtStr}'::date`;
                }
                else {
                    pgStatement.Statement.Value = `'${dtStr} ${dt.getHours()}:${dt.getMinutes()}'::timestamp`;
                }
            }
            if ([myorm_core_1.Operation.CONSTAINS, myorm_core_1.Operation.ENDWITH, myorm_core_1.Operation.STARTWITH].filter(s => s == pgStatement.Statement.Kind).length > 0) {
                throw new InvalidOperationException_1.default(`Can execute ${pgStatement.Statement.Kind.toString().toLocaleLowerCase()} only with text and array fields`);
            }
        }
        else {
            operation[1] = `$$${operation[1]}`;
            operation[2] = `${operation[2]}$$`;
        }
        return `"${this._table}".${column} ${operation[0]} ${operation[1]}${pgStatement.Statement.Value}${operation[2]}`;
    }
    EvaluateOrderBy(ordering) {
        let column = Type_1.default.GetColumnName(this._type, ordering.Field.toString());
        return ` "${this._table}".${column} ${ordering.Order}`;
    }
    GetOperators(operation) {
        switch (operation) {
            case myorm_core_1.Operation.EQUALS: return ["=", "", ""];
            case myorm_core_1.Operation.CONSTAINS: return ["ilike", "%", "%"];
            case myorm_core_1.Operation.STARTWITH:
                return ["ilike", "", "%"];
                ;
            case myorm_core_1.Operation.ENDWITH:
                return ["ilike", "%", ""];
                ;
            case myorm_core_1.Operation.GREATHER:
                return [">", "", ""];
                ;
            case myorm_core_1.Operation.GREATHEROREQUALS:
                return [">=", "", ""];
                ;
            case myorm_core_1.Operation.SMALLER:
                return ["<", "", ""];
                ;
            case myorm_core_1.Operation.SMALLEROREQUALS:
                return ["<=", "", ""];
                ;
            case myorm_core_1.Operation.NOTEQUALS:
                return ["!=", "", ""];
                ;
            default: throw new NotImplementedException_1.default(`The operation ${operation} is not supported`);
        }
    }
    Reset() {
        this._ordering = [];
        this._includes = [];
        this._limit = undefined;
        this._set = new PGSetValue();
        this.ResetFilters();
    }
    ResetFilters() {
        this._statements = [];
        this._whereAsString = undefined;
        PGSetHelper_1.default.CleanORMData(this);
    }
    IsCorrectType(obj) {
        let sameCTor = obj && obj.constructor && obj.constructor == this._type;
        if (sameCTor)
            return true;
        if (obj.prototype == this._type)
            return true;
        if (obj.prototype && obj.prototype.constructor == this._type)
            return true;
        let objectKeys = Object.keys(obj);
        for (let map of this._maps) {
            let v = obj[map.Field];
            if (v == undefined) {
                let exists = objectKeys.filter(s => s == map.Field).length > 0;
                if (!exists) {
                    let allowNull = SchemasDecorators_1.default.AllowNullValue(this._type, map.Field);
                    if (!allowNull)
                        return false;
                }
            }
        }
        obj.__proto__ = this._type;
        return true;
    }
    BuildObjects(r) {
        return __awaiter(this, void 0, void 0, function* () {
            let list = [];
            for (let row of r.rows) {
                let instance = Reflect.construct(this._type, []);
                for (let map of this._maps) {
                    let type = Type_1.default.GetDesingType(this._type, map.Field);
                    let relation = SchemasDecorators_1.default.GetRelationAttribute(this._type, map.Field);
                    if ((!type || type === Array) && relation)
                        type = relation.TypeBuilder();
                    if (!this._context.IsMapped(type)) {
                        let v = Reflect.get(row, map.Column);
                        let vType = Type_1.default.CastType(map.Type);
                        if (v != undefined) {
                            if ([DBTypes_1.DBTypes.INTEGER, DBTypes_1.DBTypes.LONG, DBTypes_1.DBTypes.SERIAL].includes(vType))
                                Reflect.set(instance, map.Field, Number.parseInt(v));
                            else if (DBTypes_1.DBTypes.DOUBLE == vType)
                                Reflect.set(instance, map.Field, Number.parseFloat(v));
                            else if ([DBTypes_1.DBTypes.DATE, DBTypes_1.DBTypes.DATETIME].includes(vType)) {
                                try {
                                    v = new Date(v);
                                }
                                catch (_a) { }
                                Reflect.set(instance, map.Field, v);
                            }
                            else if (DBTypes_1.DBTypes.TEXT == vType)
                                Reflect.set(instance, map.Field, v.toString());
                            else
                                Reflect.set(instance, map.Field, v);
                        }
                        else
                            Reflect.set(instance, map.Field, v);
                    }
                    else {
                        if (Reflect.get(row, map.Column) == undefined) {
                            if (this._includes.filter(s => s.Field == map.Field).length > 0) {
                                Type_1.default.InjectMetadata(instance, {
                                    Field: map.Field,
                                    Type: map.Type,
                                    Value: Reflect.get(row, map.Column),
                                    Loaded: true
                                });
                            }
                            continue;
                        }
                        let includeType = this._includes.filter(s => s.Field == map.Field);
                        let loaded = false;
                        if (includeType.length > 0) {
                            loaded = true;
                            let colletion = this._context.Collection(type);
                            if (colletion == undefined)
                                continue;
                            colletion["Reset"]();
                            let subKey = SchemasDecorators_1.default.ExtractPrimaryKey(type);
                            if ((relation === null || relation === void 0 ? void 0 : relation.Relation) == RelationType_1.RelationType.MANY_TO_MANY || (relation === null || relation === void 0 ? void 0 : relation.Relation) == RelationType_1.RelationType.ONE_TO_MANY) {
                                let values = Reflect.get(row, map.Column);
                                if (!values || values.length == 0) {
                                    Reflect.set(instance, map.Field, []);
                                }
                                else {
                                    colletion.Where({
                                        Field: subKey,
                                        Kind: myorm_core_1.Operation.EQUALS,
                                        Value: values[0]
                                    });
                                    for (let i = 0; i < values.length; i++) {
                                        if (i == 0)
                                            continue;
                                        colletion.Or({
                                            Field: subKey,
                                            Kind: myorm_core_1.Operation.EQUALS,
                                            Value: values[i]
                                        });
                                    }
                                    let subObjets = yield colletion.ToListAsync();
                                    Reflect.set(instance, map.Field, subObjets);
                                }
                            }
                            else {
                                colletion.Where({
                                    Field: subKey,
                                    Kind: myorm_core_1.Operation.EQUALS,
                                    Value: Reflect.get(row, map.Column)
                                });
                                let subObjet = yield colletion.FirstOrDefaultAsync();
                                Reflect.set(instance, map.Field, subObjet);
                            }
                        }
                        Type_1.default.InjectMetadata(instance, {
                            Field: map.Field,
                            Type: map.Type,
                            Value: Reflect.get(row, map.Column),
                            Loaded: loaded
                        });
                    }
                }
                list.push(instance);
            }
            return list;
        });
    }
}
exports.default = PGDBSet;
class PGSetValue {
    constructor() {
        this._sets = [];
    }
    Add(key, value) {
        let i = this._sets.filter(s => s.Key == key);
        if (i.length > 0) {
            i[0].Value = value;
        }
        else {
            this._sets.push({ Key: key, Value: value });
        }
    }
    Get() {
        return this._sets;
    }
}
var OrderDirection;
(function (OrderDirection) {
    OrderDirection["ASC"] = "asc";
    OrderDirection["DESC"] = "desc";
})(OrderDirection || (OrderDirection = {}));
var StatementType;
(function (StatementType) {
    StatementType["WHERE"] = "where";
    StatementType["OR"] = "or";
    StatementType["AND"] = "and";
})(StatementType || (StatementType = {}));
//# sourceMappingURL=PGDBSet.js.map