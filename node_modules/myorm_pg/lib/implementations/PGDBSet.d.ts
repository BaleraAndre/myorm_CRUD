import { IStatement, IFluentField, AbstractSet } from "myorm_core";
import Type from "../core/design/Type";
import PGDBContext from "./PGDBContext";
export default class PGDBSet<T extends Object> extends AbstractSet<T> {
    private _type;
    private _table;
    private _maps;
    private _manager;
    private _context;
    private _statements;
    private _ordering;
    private _includes;
    private _limit?;
    private _offset?;
    private _set;
    private _whereAsString?;
    constructor(cTor: {
        new (...args: any[]): T;
    }, context: PGDBContext);
    AddObjectAndRelationsAsync(obj: T, relations: (keyof T)[]): Promise<T>;
    AddAsync(obj: T): Promise<T>;
    protected AddObjectAsync(obj: T, cascade?: boolean, relations?: (keyof T)[], visiteds?: any[]): Promise<T>;
    UpdateSelectionAsync(): Promise<void>;
    Set<K extends keyof T>(key: K, value: T[K]): AbstractSet<T>;
    UpdateAsync(obj: T): Promise<T>;
    UpdateObjectAndRelationsAsync(obj: T, relations: (keyof T)[]): Promise<T>;
    private UpdateObjectAsync;
    protected GetChanges(meta: ReturnType<typeof Type.ExtractMetadata>, subObj: any, subType: new (...args: any[]) => unknown): number[];
    DeleteSelectionAsync(): Promise<void>;
    DeleteAsync(obj: T): Promise<T>;
    Where<K extends keyof T>(statement: IStatement<T, K>): AbstractSet<T>;
    And<K extends keyof T>(statement: IStatement<T, K>): AbstractSet<T>;
    Or<K extends keyof T>(statement: IStatement<T, K>): AbstractSet<T>;
    OrderBy<K extends keyof T>(key: K): AbstractSet<T>;
    Join<K extends keyof T>(key: K): AbstractSet<T>;
    OrderDescendingBy<K extends keyof T>(key: K): AbstractSet<T>;
    Limit(limit: number): AbstractSet<T>;
    Offset(offset: number): AbstractSet<T>;
    Take(quantity: number): AbstractSet<T>;
    CountAsync(): Promise<number>;
    ToListAsync(): Promise<T[]>;
    FirstOrDefaultAsync(): Promise<T | undefined>;
    WhereField<U extends keyof T, R extends PGDBSet<T>>(field: U): IFluentField<T, U, R>;
    AndField<U extends keyof T, R extends PGDBSet<T>>(field: U): IFluentField<T, U, R>;
    OrField<U extends keyof T, R extends PGDBSet<T>>(field: U): IFluentField<T, U, R>;
    WhereAsString<R extends PGDBSet<T>>(where: string): R;
    LoadRelationOn<U extends keyof T, R extends PGDBSet<T>>(field: U): R;
    private CreatePromisse;
    CleanQueryTree(): void;
    private CreateValueStatement;
    private EvaluateWhere;
    private EvaluateStatement;
    private EvaluateOrderBy;
    private GetOperators;
    private Reset;
    private ResetFilters;
    private IsCorrectType;
    private BuildObjects;
}
//# sourceMappingURL=PGDBSet.d.ts.map