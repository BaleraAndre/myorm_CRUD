import { IStatement, AbstractContext, IJoiningQuery, IJoinSelectable, AbstractSet } from "myorm_core";
import PGDBManager from "./PGDBManager";
export default abstract class PGDBContext extends AbstractContext {
    protected _manager: PGDBManager;
    private _mappedTypes;
    constructor(manager: PGDBManager);
    GetMappedTypes(): (new (...args: any[]) => unknown)[];
    IsMapped(type: {
        new (...args: any[]): unknown;
    }): boolean;
    Collection<T extends Object>(cTor: {
        new (...args: any[]): T;
    }): AbstractSet<T>;
    UpdateDatabaseAsync(): Promise<void>;
    ExecuteNonQuery(query: string): Promise<void>;
    ExecuteQuery(query: string): Promise<any>;
    Join(...args: (new (...args: any[]) => Object)[]): IJoiningQuery;
}
export declare class JoiningQuery implements IJoiningQuery {
    private _context;
    private _stack;
    private _onStatements;
    constructor(context: PGDBContext, stack: (new (...args: any[]) => Object)[]);
    On<C extends Object, U extends Object>(cT: {
        new (...args: any[]): C;
    }, cKey: keyof C, uT: {
        new (...args: any[]): U;
    }, uKey: keyof U): IJoiningQuery;
    Where<C extends Object, K extends keyof C>(cT: new (...args: any[]) => C, statement: IStatement<C, K>): IJoiningQuery;
    And<C extends Object, K extends keyof C>(cT: new (...args: any[]) => C, statement: IStatement<C, K>): IJoiningQuery;
    Or<C extends Object, K extends keyof C>(cT: new (...args: any[]) => C, statement: IStatement<C, K>): IJoiningQuery;
    Select<C extends Object>(cT: new (...args: any[]) => C): IJoinSelectable<C>;
    private CheckIfTypeIsAllowed;
}
export declare class JoinSelectable<T extends Object> implements IJoinSelectable<T> {
    private _context;
    private _stack;
    private _onStatements;
    private _type;
    constructor(cT: new (...args: any[]) => T, context: PGDBContext, stack: IUnion[], onStack: [string, string][]);
    Take(quantity: number): IJoinSelectable<T>;
    Offset(offset: number): IJoinSelectable<T>;
    Limit(limit: number): IJoinSelectable<T>;
    CountAsync(): Promise<number>;
    Join<K extends keyof T>(key: K): IJoinSelectable<T>;
    OrderBy<K extends keyof T>(key: K): IJoinSelectable<T>;
    OrderDescendingBy<K extends keyof T>(key: K): IJoinSelectable<T>;
    ToListAsync(): Promise<T[]>;
    protected PrepareQuery(): AbstractSet<T>;
    FirstOrDefaultAsync(): Promise<T | undefined>;
    private Reset;
}
interface IUnion {
    Type: unknown;
    Key?: string;
}
export {};
//# sourceMappingURL=PGDBContext.d.ts.map