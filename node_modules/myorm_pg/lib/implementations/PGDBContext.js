"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JoinSelectable = exports.JoiningQuery = void 0;
const myorm_core_1 = require("myorm_core");
const SchemasDecorators_1 = __importDefault(require("../core/decorators/SchemasDecorators"));
const Type_1 = __importDefault(require("../core/design/Type"));
const ConstraintFailException_1 = __importDefault(require("../core/exceptions/ConstraintFailException"));
const InvalidOperationException_1 = __importDefault(require("../core/exceptions/InvalidOperationException"));
const TypeNotMappedException_1 = __importDefault(require("../core/exceptions/TypeNotMappedException"));
const PGDBSet_1 = __importDefault(require("./PGDBSet"));
const PGSetHelper_1 = __importDefault(require("./PGSetHelper"));
class PGDBContext extends myorm_core_1.AbstractContext {
    constructor(manager) {
        super();
        this._manager = manager;
    }
    GetMappedTypes() {
        if (this._mappedTypes != undefined)
            return this._mappedTypes;
        this._mappedTypes = [];
        let props = Object.keys(this);
        for (let prop of props) {
            if (this[prop].constructor == PGDBSet_1.default) {
                this._mappedTypes.push(this[prop]["_type"]);
            }
        }
        return this._mappedTypes;
    }
    IsMapped(type) {
        return this.GetMappedTypes().filter(t => t == type).length > 0;
    }
    Collection(cTor) {
        for (let prop of Object.keys(this)) {
            let type = this[prop]["_type"];
            if (type == undefined)
                continue;
            if (type == cTor)
                return this[prop];
        }
        throw new TypeNotMappedException_1.default(`${cTor.name} is not mapped in this context`);
    }
    UpdateDatabaseAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            let dbName = this._manager["_connection"].DataBaseName;
            if (!(yield this._manager.CheckDatabaseAsync(dbName)))
                yield this._manager.CreateDataBaseAsync(dbName);
            for (let type of this.GetMappedTypes()) {
                yield this._manager.UpdateDatabaseForEntityAsync(type);
            }
        });
    }
    ExecuteNonQuery(query) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._manager.ExecuteNonQueryAsync(query);
        });
    }
    ExecuteQuery(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._manager.ExecuteAsync(query);
        });
    }
    Join(...args) {
        return new JoiningQuery(this, args);
    }
}
exports.default = PGDBContext;
class JoiningQuery {
    constructor(context, stack) {
        this._stack = [];
        this._onStatements = [];
        this._context = context;
        this._stack.push(...stack.map(s => { return { Type: s }; }));
        let notMappedTypes = this._stack.filter(s => this._context.Collection(s.Type) == undefined);
        if (notMappedTypes.length > 0) {
            this._stack = [];
            throw new InvalidOperationException_1.default(`The type ${notMappedTypes[0].Type.name} is not mapped`);
        }
    }
    On(cT, cKey, uT, uKey) {
        this.CheckIfTypeIsAllowed(cT);
        this.CheckIfTypeIsAllowed(cT);
        let leftIndex = this._stack.findIndex(s => s.Type == cT);
        let rightIndex = this._stack.findIndex(s => s.Type == uT);
        if (rightIndex - leftIndex != 1)
            throw new InvalidOperationException_1.default(`The On statement must follow the same order than Join`);
        this._onStatements.push([cKey.toString(), uKey.toString()]);
        return this;
    }
    Where(cT, statement) {
        this.CheckIfTypeIsAllowed(cT);
        let set = this._context.Collection(cT);
        set.Where(statement);
        return this;
    }
    And(cT, statement) {
        this.CheckIfTypeIsAllowed(cT);
        let set = this._context.Collection(cT);
        set.And(statement);
        return this;
    }
    Or(cT, statement) {
        this.CheckIfTypeIsAllowed(cT);
        let set = this._context.Collection(cT);
        set.Or(statement);
        return this;
    }
    Select(cT) {
        return new JoinSelectable(cT, this._context, this._stack, this._onStatements);
    }
    CheckIfTypeIsAllowed(cT) {
        let set = this._context.Collection(cT);
        if (!set)
            throw new InvalidOperationException_1.default(`The type ${cT.name} is not mapped`);
        let index = this._stack.findIndex(s => s.Type == cT);
        if (index == -1)
            throw new InvalidOperationException_1.default(`The type ${cT.name} is not inside the Join list`);
    }
}
exports.JoiningQuery = JoiningQuery;
class JoinSelectable {
    constructor(cT, context, stack, onStack) {
        this._stack = [];
        this._onStatements = [];
        this._type = cT;
        this._context = context;
        this._stack = stack;
        this._onStatements = onStack;
    }
    Take(quantity) {
        var _a;
        (_a = this._context.Collection(this._type)) === null || _a === void 0 ? void 0 : _a.Take(quantity);
        return this;
    }
    Offset(offset) {
        var _a;
        (_a = this._context.Collection(this._type)) === null || _a === void 0 ? void 0 : _a.Offset(offset);
        return this;
    }
    Limit(limit) {
        var _a;
        (_a = this._context.Collection(this._type)) === null || _a === void 0 ? void 0 : _a.Limit(limit);
        return this;
    }
    CountAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            let set = this.PrepareQuery();
            let c = yield set.CountAsync();
            this.Reset();
            return c;
        });
    }
    Join(key) {
        var _a;
        (_a = this._context.Collection(this._type)) === null || _a === void 0 ? void 0 : _a.Join(key);
        return this;
    }
    OrderBy(key) {
        var _a;
        (_a = this._context.Collection(this._type)) === null || _a === void 0 ? void 0 : _a.OrderBy(key);
        return this;
    }
    OrderDescendingBy(key) {
        var _a;
        (_a = this._context.Collection(this._type)) === null || _a === void 0 ? void 0 : _a.OrderDescendingBy(key);
        return this;
    }
    ToListAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            let set = this.PrepareQuery();
            let r = yield set.ToListAsync();
            this.Reset();
            return r;
        });
    }
    PrepareQuery() {
        if (this._stack.length > this._onStatements.length + 1)
            throw new InvalidOperationException_1.default(`There is no enought On clausules to join all selected types`);
        if (this._stack.length < this._onStatements.length + 1)
            throw new InvalidOperationException_1.default(`There is more On clausules than join types selecteds`);
        let selectedSideSet = this._context.Collection(this._type);
        let leftSideType = this._stack[0].Type;
        let selectedTable = Type_1.default.GetTableName(this._type);
        let query = `select distinct "${selectedTable}".* from "${Type_1.default.GetTableName(leftSideType)}" `;
        for (let i = 1; i < this._stack.length; i++) {
            let rightSideType = this._stack[i].Type;
            let leftSideTable = Type_1.default.GetTableName(leftSideType);
            let rigthSideTable = Type_1.default.GetTableName(rightSideType);
            let onStatement = this._onStatements[i - 1];
            let leftSideField = onStatement[0];
            let rightSideField = onStatement[1];
            let leftSideIsArray = Type_1.default.GetDesingType(leftSideType, leftSideField) == Array;
            let rightSideIsArray = Type_1.default.GetDesingType(rightSideType, rightSideField) == Array;
            let rightSideTypeMap = Type_1.default.GetColumnNameAndType(rightSideType);
            let leftSideTypeMap = Type_1.default.GetColumnNameAndType(leftSideType);
            query += ` inner join "${rigthSideTable}" on `;
            let leftSideRelation = SchemasDecorators_1.default.GetRelationAttribute(leftSideType, leftSideField);
            let rightSideRelation = SchemasDecorators_1.default.GetRelationAttribute(rightSideType, rightSideField);
            if ((leftSideIsArray && rightSideIsArray) || (!leftSideIsArray && !rightSideIsArray)) {
                query += ` "${leftSideTable}".${Type_1.default.GetColumnName(leftSideType, leftSideField)} = "${rigthSideTable}".${Type_1.default.GetColumnName(rightSideType, rightSideField)} `;
            }
            else if (leftSideIsArray && !rightSideIsArray) {
                let rightSideDBType;
                if (rightSideRelation) {
                    let rType = rightSideRelation.TypeBuilder();
                    let rkey = SchemasDecorators_1.default.ExtractPrimaryKey(rType);
                    if (!rkey)
                        throw new ConstraintFailException_1.default(`The type ${rType.name} was no one primary key field`);
                    rightSideDBType = Type_1.default.CastType(rightSideTypeMap.filter(s => s.Field == rkey)[0].Type);
                }
                else {
                    rightSideDBType = Type_1.default.CastType(rightSideTypeMap.filter(s => s.Field == rightSideField)[0].Type);
                }
                if (leftSideRelation) {
                    let lType = leftSideRelation.TypeBuilder();
                    let key = SchemasDecorators_1.default.ExtractPrimaryKey(lType);
                    if (!key)
                        throw new ConstraintFailException_1.default(`The type ${lType.name} was no one primary key field`);
                    let relationMap = Type_1.default.GetColumnNameAndType(lType);
                    let leftSideDBType = Type_1.default.CastType(relationMap.filter(s => s.Field == key)[0].Type);
                    let leftColumnName = leftSideTypeMap.filter(s => s.Field == leftSideField)[0].Column;
                    let rightColumnName = rightSideTypeMap.filter(s => s.Field == rightSideField)[0].Column;
                    if (leftSideDBType != rightSideDBType) {
                        throw new InvalidOperationException_1.default(`${leftSideType.name}.${leftSideField} and ${rightSideType.name}.${rightSideField} must be the same type to join`);
                    }
                    query += ` "${rigthSideTable}".${rightColumnName} = ANY("${leftSideTable}".${leftColumnName})`;
                }
                else {
                    let dataType = SchemasDecorators_1.default.GetDataTypeAttribute(leftSideType, leftSideField);
                    if (!dataType) {
                        throw new InvalidOperationException_1.default(`Can not find the DataAttributeof ${leftSideType.name}.${leftSideField}`);
                    }
                    let elementType = Type_1.default.ExtractElementType(dataType);
                    if (!elementType)
                        throw new InvalidOperationException_1.default(`Can not determine the array element type of ${leftSideType.name}.${leftSideField}`);
                    let leftColumnName = leftSideTypeMap.filter(s => s.Field == leftSideField)[0].Column;
                    let rightColumnName = rightSideTypeMap.filter(s => s.Field == rightSideField)[0].Column;
                    let areNumbers = Type_1.default.IsNumber(Type_1.default.CastType(elementType)) && Type_1.default.IsNumber(rightSideDBType);
                    let areString = Type_1.default.IsText(Type_1.default.CastType(elementType)) && Type_1.default.IsText(rightSideDBType);
                    let areDate = Type_1.default.IsDate(Type_1.default.CastType(elementType)) && Type_1.default.IsDate(rightSideDBType);
                    let areArray = Type_1.default.IsArray(Type_1.default.CastType(elementType)) && Type_1.default.IsArray(rightSideDBType);
                    let areSameType = this._context["_manager"]["CastToPostgreSQLType"](elementType) == this._context["_manager"]["CastToPostgreSQLType"](rightSideDBType);
                    let areSerial = this._context["_manager"]["CastToPostgreSQLType"](elementType) == "serial" && this._context["_manager"]["CastToPostgreSQLType"](rightSideDBType) == "serial";
                    if (!(areNumbers || areString || areDate || areArray || areSameType || areSerial))
                        throw new InvalidOperationException_1.default(`${leftSideType.name}.${leftSideField} and ${rightSideType.name}.${rightSideField} must be the same type to join`);
                    query += ` "${rigthSideTable}".${rightColumnName} = ANY("${leftSideTable}".${leftColumnName})`;
                }
            }
            else if (rightSideIsArray && !leftSideIsArray) {
                let leftSideDBType;
                if (leftSideRelation) {
                    let rType = leftSideRelation.TypeBuilder();
                    let rkey = SchemasDecorators_1.default.ExtractPrimaryKey(rType);
                    if (!rkey)
                        throw new ConstraintFailException_1.default(`The type ${rType.name} was no one primary key field`);
                    leftSideDBType = Type_1.default.CastType(leftSideTypeMap.filter(s => s.Field == rkey)[0].Type);
                }
                else {
                    leftSideDBType = Type_1.default.CastType(leftSideTypeMap.filter(s => s.Field == leftSideField)[0].Type);
                }
                if (rightSideRelation) {
                    let rType = rightSideRelation.TypeBuilder();
                    let key = SchemasDecorators_1.default.ExtractPrimaryKey(rType);
                    if (!key)
                        throw new ConstraintFailException_1.default(`The type ${rType.name} was no one primary key field`);
                    let relationMap = Type_1.default.GetColumnNameAndType(rType);
                    let rightSideDBType = Type_1.default.CastType(relationMap.filter(s => s.Field == key)[0].Type);
                    let leftColumnName = leftSideTypeMap.filter(s => s.Field == leftSideField)[0].Column;
                    let rightColumnName = rightSideTypeMap.filter(s => s.Field == rightSideField)[0].Column;
                    if (leftSideDBType != rightSideDBType) {
                        throw new InvalidOperationException_1.default(`${leftSideType.name}.${leftSideField} and ${rightSideType.name}.${rightSideField} must be the same type to join`);
                    }
                    query += ` "${leftSideTable}".${leftColumnName} = ANY("${rigthSideTable}".${rightColumnName})`;
                }
                else {
                    let dataType = SchemasDecorators_1.default.GetDataTypeAttribute(rightSideType, rightSideField);
                    if (!dataType) {
                        throw new InvalidOperationException_1.default(`Can not find the DataAttributeof ${rightSideType.name}.${rightSideField}`);
                    }
                    let elementType = Type_1.default.ExtractElementType(dataType);
                    if (!elementType)
                        throw new InvalidOperationException_1.default(`Can not determine the array element type of ${rightSideType.name}.${rightSideField}`);
                    let leftColumnName = leftSideTypeMap.filter(s => s.Field == leftSideField)[0].Column;
                    let rightColumnName = rightSideTypeMap.filter(s => s.Field == rightSideField)[0].Column;
                    let areNumbers = Type_1.default.IsNumber(Type_1.default.CastType(elementType)) && Type_1.default.IsNumber(leftSideDBType);
                    let areString = Type_1.default.IsText(Type_1.default.CastType(elementType)) && Type_1.default.IsText(leftSideDBType);
                    let areDate = Type_1.default.IsDate(Type_1.default.CastType(elementType)) && Type_1.default.IsDate(leftSideDBType);
                    let areArray = Type_1.default.IsArray(Type_1.default.CastType(elementType)) && Type_1.default.IsArray(leftSideDBType);
                    let areSameType = this._context["_manager"]["CastToPostgreSQLType"](elementType) == this._context["_manager"]["CastToPostgreSQLType"](leftSideDBType);
                    let areSerial = this._context["_manager"]["CastToPostgreSQLType"](elementType) == "serial" && this._context["_manager"]["CastToPostgreSQLType"](leftSideDBType) == "serial";
                    if (!(areNumbers || areString || areDate || areArray || areSameType || areSerial))
                        throw new InvalidOperationException_1.default(`${leftSideType.name}.${leftSideField} and ${rightSideType.name}.${rightSideField} must be the same type to join`);
                    query += ` "${leftSideTable}".${leftColumnName} = ANY("${rigthSideTable}".${rightColumnName})`;
                }
            }
            leftSideType = this._stack[i].Type;
        }
        let where = "";
        for (let type of this._stack) {
            let set = this._context.Collection(type.Type);
            let statements = set["_statements"];
            for (let s of statements) {
                let operation = s.StatementType.toString();
                if (operation == "where" && where.length > 0)
                    operation = "and";
                where += ` ${operation} ${set["EvaluateStatement"](s)}`;
            }
        }
        PGSetHelper_1.default.InjectSQL(selectedSideSet, query);
        PGSetHelper_1.default.InjectWhere(selectedSideSet, where);
        return selectedSideSet;
    }
    FirstOrDefaultAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            let set = this.PrepareQuery();
            let i = yield set.FirstOrDefaultAsync();
            this.Reset();
            return i;
        });
    }
    Reset() {
        for (let i = 1; i < this._stack.length; i++) {
            let type = this._stack[i].Type;
            let set = this._context.Collection(type);
            set["Reset"]();
        }
        this._stack = [];
        this._onStatements = [];
    }
}
exports.JoinSelectable = JoinSelectable;
//# sourceMappingURL=PGDBContext.js.map